/**
 * SQLite SQL generator
 */

/**
 * Generate a header comment for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Header comment
 */
exports.headerComment = (schema) => {
  return `-- SQLite Script Generated for Schema: ${schema.name}
-- Created: ${new Date().toISOString()}
-- Description: ${schema.description || 'Database schema generated by Database Creator tool'}

PRAGMA foreign_keys = ON;`;
};

/**
 * Generate CREATE TABLE statement for SQLite
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {string} - CREATE TABLE statement
 */
exports.createTableStatement = (table, schema) => {
  // Map MySQL data types to SQLite
  const mappedColumns = table.columns.map(column => ({
    ...column,
    dataType: mapDataType(column.dataType)
  }));
  
  const columnDefinitions = mappedColumns.map(column => {
    let definition = `"${column.name}" ${column.dataType}`;
    
    if (column.isNullable === false) {
      definition += ' NOT NULL';
    }
    
    if (column.defaultValue) {
      definition += ` DEFAULT ${formatDefaultValue(column.defaultValue)}`;
    }
    
    if (column.isPrimaryKey && !isCompositePrimaryKey(table)) {
      definition += ' PRIMARY KEY';
      
      // Auto-increment for INTEGER primary keys
      if (column.dataType.toUpperCase() === 'INTEGER') {
        definition += ' AUTOINCREMENT';
      }
    }
    
    return definition;
  });
  
  // Handle composite primary keys
  const primaryKeyColumns = table.columns.filter(column => column.isPrimaryKey);
  if (primaryKeyColumns.length > 1) {
    const pkDefinition = `PRIMARY KEY (${primaryKeyColumns.map(col => `"${col.name}"`).join(', ')})`;
    columnDefinitions.push(pkDefinition);
  }
  
  // Foreign key constraints
  const foreignKeys = table.columns.filter(column => column.isForeignKey && column.references);
  foreignKeys.forEach(column => {
    let constraint = `FOREIGN KEY ("${column.name}") REFERENCES "${column.references.table}" ("${column.references.column}")`;
    
    if (column.references.onDelete) {
      constraint += ` ON DELETE ${column.references.onDelete}`;
    }
    
    if (column.references.onUpdate) {
      constraint += ` ON UPDATE ${column.references.onUpdate}`;
    }
    
    columnDefinitions.push(constraint);
  });
  
  // Unique constraints
  const uniqueColumns = table.columns.filter(column => column.isUnique && !column.isPrimaryKey);
  uniqueColumns.forEach(column => {
    columnDefinitions.push(`UNIQUE ("${column.name}")`);
  });
  
  return `-- Table: ${table.name}
CREATE TABLE IF NOT EXISTS "${table.name}" (
  ${columnDefinitions.join(',\n  ')}
);

-- Add table description as comment
-- SQLite doesn't support table comments, storing in metadata table
INSERT OR REPLACE INTO "schema_metadata" ("table_name", "description") 
VALUES ('${table.name}', '${(table.description || '').replace(/'/g, "''")}');`;
};

/**
 * Generate CREATE INDEX statements for SQLite
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {Array} - CREATE INDEX statements
 */
exports.createIndexStatements = (table, schema) => {
  const indexes = [];
  
  // Add indexes for foreign keys
  const foreignKeyColumns = table.columns.filter(column => column.isForeignKey);
  
  foreignKeyColumns.forEach(column => {
    indexes.push(`-- Index for foreign key: ${column.name}
CREATE INDEX "idx_${table.name}_${column.name}" ON "${table.name}" ("${column.name}");`);
  });
  
  // Create metadata table for comments (only once)
  if (table === schema.tables[0]) {
    indexes.unshift(`-- Create metadata table for comments
CREATE TABLE IF NOT EXISTS "schema_metadata" (
  "table_name" TEXT PRIMARY KEY,
  "description" TEXT
);`);

    // Add column descriptions
    table.columns.forEach(column => {
      if (column.description) {
        indexes.push(`INSERT OR REPLACE INTO "schema_metadata" ("table_name", "description") 
VALUES ('${table.name}.${column.name}', '${(column.description || '').replace(/'/g, "''")}');`);
      }
    });
  }
  
  return indexes;
};

/**
 * Generate ALTER TABLE statement for adding foreign key
 * SQLite doesn't support ALTER TABLE ADD CONSTRAINT, so this is a no-op
 * @param {string} tableName - Table name
 * @param {Object} foreignKey - Foreign key constraint
 * @returns {string} - Comment indicating limitation
 */
exports.addForeignKeyStatement = (tableName, foreignKey) => {
  return `-- Note: SQLite doesn't support ALTER TABLE ADD CONSTRAINT
-- Foreign keys must be defined in the CREATE TABLE statement`;
};

/**
 * Format default value for SQLite
 * @param {string} value - Default value
 * @returns {string} - Formatted default value
 */
function formatDefaultValue(value) {
  if (value === 'CURRENT_TIMESTAMP') {
    return "CURRENT_TIMESTAMP";
  } else if (value === 'NULL') {
    return 'NULL';
  }
  return `'${value}'`;
}

/**
 * Check if table has composite primary key
 * @param {Object} table - Table object
 * @returns {boolean} - True if table has composite primary key
 */
function isCompositePrimaryKey(table) {
  return table.columns.filter(column => column.isPrimaryKey).length > 1;
}

/**
 * Map MySQL data types to SQLite data types
 * @param {string} dataType - MySQL data type
 * @returns {string} - SQLite data type
 */
function mapDataType(dataType) {
  // SQLite has only 5 storage classes: NULL, INTEGER, REAL, TEXT, and BLOB
  const typeMap = {
    'INT': 'INTEGER',
    'INTEGER': 'INTEGER',
    'TINYINT': 'INTEGER',
    'SMALLINT': 'INTEGER',
    'MEDIUMINT': 'INTEGER',
    'BIGINT': 'INTEGER',
    'FLOAT': 'REAL',
    'DOUBLE': 'REAL',
    'DECIMAL': 'REAL',
    'CHAR': 'TEXT',
    'VARCHAR': 'TEXT',
    'TEXT': 'TEXT',
    'TINYTEXT': 'TEXT',
    'MEDIUMTEXT': 'TEXT',
    'LONGTEXT': 'TEXT',
    'BOOLEAN': 'INTEGER',
    'DATE': 'TEXT',
    'DATETIME': 'TEXT',
    'TIMESTAMP': 'TEXT',
    'TIME': 'TEXT',
    'YEAR': 'INTEGER',
    'BLOB': 'BLOB',
    'TINYBLOB': 'BLOB',
    'MEDIUMBLOB': 'BLOB',
    'LONGBLOB': 'BLOB'
  };
  
  // Extract type and ignore size
  const match = dataType.match(/^(\w+)(?:\(([^)]+)\))?$/);
  if (!match) return 'TEXT';
  
  const type = match[1].toUpperCase();
  
  // Map the type, defaulting to TEXT
  return typeMap[type] || 'TEXT';
}

module.exports = exports;
