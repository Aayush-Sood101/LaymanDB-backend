/**
 * PostgreSQL SQL generator
 */

/**
 * Generate a header comment for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Header comment
 */
exports.headerComment = (schema) => {
  return `-- PostgreSQL Script Generated for Schema: ${schema.name}
-- Created: ${new Date().toISOString()}
-- Description: ${schema.description || 'Database schema generated by Database Creator tool'}

BEGIN;`;
};

/**
 * Generate CREATE TABLE statement for PostgreSQL
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {string} - CREATE TABLE statement
 */
exports.createTableStatement = (table, schema) => {
  // Map MySQL data types to PostgreSQL
  const mappedColumns = table.columns.map(column => ({
    ...column,
    dataType: mapDataType(column.dataType)
  }));
  
  const columnDefinitions = mappedColumns.map(column => {
    let definition = `"${column.name}" ${column.dataType}`;
    
    if (column.isNullable === false) {
      definition += ' NOT NULL';
    }
    
    if (column.defaultValue) {
      definition += ` DEFAULT ${formatDefaultValue(column.defaultValue)}`;
    }
    
    if (column.isPrimaryKey && !isCompositePrimaryKey(table)) {
      definition += ' PRIMARY KEY';
    }
    
    return definition;
  });
  
  // Handle composite primary keys
  const primaryKeyColumns = table.columns.filter(column => column.isPrimaryKey);
  if (primaryKeyColumns.length > 1) {
    const pkDefinition = `PRIMARY KEY (${primaryKeyColumns.map(col => `"${col.name}"`).join(', ')})`;
    columnDefinitions.push(pkDefinition);
  }
  
  // Foreign key constraints
  const foreignKeys = table.columns.filter(column => column.isForeignKey && column.references);
  foreignKeys.forEach(column => {
    const fkDefinition = `CONSTRAINT "fk_${table.name}_${column.name}" FOREIGN KEY ("${column.name}") REFERENCES "${column.references.table}" ("${column.references.column}")`;
    let constraint = fkDefinition;
    
    if (column.references.onDelete) {
      constraint += ` ON DELETE ${column.references.onDelete}`;
    }
    
    if (column.references.onUpdate) {
      constraint += ` ON UPDATE ${column.references.onUpdate}`;
    }
    
    columnDefinitions.push(constraint);
  });
  
  // Unique constraints
  const uniqueColumns = table.columns.filter(column => column.isUnique && !column.isPrimaryKey);
  uniqueColumns.forEach(column => {
    columnDefinitions.push(`CONSTRAINT "unique_${table.name}_${column.name}" UNIQUE ("${column.name}")`);
  });
  
  return `-- Table: ${table.name}
CREATE TABLE IF NOT EXISTS "${table.name}" (
  ${columnDefinitions.join(',\n  ')}
);

-- Add table comments
COMMENT ON TABLE "${table.name}" IS '${(table.description || '').replace(/'/g, "''")}';
${mappedColumns.map(column => `COMMENT ON COLUMN "${table.name}"."${column.name}" IS '${(column.description || '').replace(/'/g, "''")}';\n`).join('')}`;
};

/**
 * Generate CREATE INDEX statements for PostgreSQL
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {Array} - CREATE INDEX statements
 */
exports.createIndexStatements = (table, schema) => {
  const indexes = [];
  
  // Add indexes for foreign keys
  const foreignKeyColumns = table.columns.filter(column => column.isForeignKey);
  
  foreignKeyColumns.forEach(column => {
    indexes.push(`-- Index for foreign key: ${column.name}
CREATE INDEX "idx_${table.name}_${column.name}" ON "${table.name}" ("${column.name}");`);
  });
  
  return indexes;
};

/**
 * Generate ALTER TABLE statement for adding foreign key
 * @param {string} tableName - Table name
 * @param {Object} foreignKey - Foreign key constraint
 * @returns {string} - ALTER TABLE statement
 */
exports.addForeignKeyStatement = (tableName, foreignKey) => {
  return `ALTER TABLE "${tableName}"
ADD CONSTRAINT "fk_${tableName}_${foreignKey.columnName}"
FOREIGN KEY ("${foreignKey.columnName}")
REFERENCES "${foreignKey.referenceTable}"("${foreignKey.referenceColumn}")
ON DELETE ${foreignKey.onDelete}
ON UPDATE ${foreignKey.onUpdate};`;
};

/**
 * Format default value for PostgreSQL
 * @param {string} value - Default value
 * @returns {string} - Formatted default value
 */
function formatDefaultValue(value) {
  if (value === 'CURRENT_TIMESTAMP') {
    return 'CURRENT_TIMESTAMP';
  } else if (value === 'NULL') {
    return 'NULL';
  }
  return `'${value}'`;
}

/**
 * Check if table has composite primary key
 * @param {Object} table - Table object
 * @returns {boolean} - True if table has composite primary key
 */
function isCompositePrimaryKey(table) {
  return table.columns.filter(column => column.isPrimaryKey).length > 1;
}

/**
 * Map MySQL data types to PostgreSQL data types
 * @param {string} dataType - MySQL data type
 * @returns {string} - PostgreSQL data type
 */
function mapDataType(dataType) {
  const typeMap = {
    'INT': 'INTEGER',
    'INTEGER': 'INTEGER',
    'TINYINT': 'SMALLINT',
    'SMALLINT': 'SMALLINT',
    'MEDIUMINT': 'INTEGER',
    'BIGINT': 'BIGINT',
    'FLOAT': 'REAL',
    'DOUBLE': 'DOUBLE PRECISION',
    'DECIMAL': 'DECIMAL',
    'CHAR': 'CHAR',
    'VARCHAR': 'VARCHAR',
    'TEXT': 'TEXT',
    'TINYTEXT': 'TEXT',
    'MEDIUMTEXT': 'TEXT',
    'LONGTEXT': 'TEXT',
    'BOOLEAN': 'BOOLEAN',
    'DATE': 'DATE',
    'DATETIME': 'TIMESTAMP',
    'TIMESTAMP': 'TIMESTAMP',
    'TIME': 'TIME',
    'YEAR': 'INTEGER',
    'BLOB': 'BYTEA',
    'TINYBLOB': 'BYTEA',
    'MEDIUMBLOB': 'BYTEA',
    'LONGBLOB': 'BYTEA'
  };
  
  // Extract type and size
  const match = dataType.match(/^(\w+)(?:\(([^)]+)\))?$/);
  if (!match) return dataType;
  
  const type = match[1].toUpperCase();
  const size = match[2];
  
  // Map the type
  const baseType = typeMap[type] || type;
  
  // Add the size if applicable
  if (size && (baseType === 'VARCHAR' || baseType === 'CHAR' || baseType === 'DECIMAL')) {
    return `${baseType}(${size})`;
  }
  
  return baseType;
}

module.exports = exports;
