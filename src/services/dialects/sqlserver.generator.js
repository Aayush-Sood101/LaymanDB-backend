/**
 * SQL Server (Microsoft SQL Server) generator
 */

/**
 * Generate a header comment for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Header comment
 */
exports.headerComment = (schema) => {
  return `-- SQL Server Script Generated for Schema: ${schema.name}
-- Created: ${new Date().toISOString()}
-- Description: ${schema.description || 'Database schema generated by Database Creator tool'}

-- Create a new database if it doesn't exist
IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = N'${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}')
BEGIN
    CREATE DATABASE [${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}];
END
GO

USE [${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}];
GO`;
};

/**
 * Generate CREATE TABLE statement for SQL Server
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {string} - CREATE TABLE statement
 */
exports.createTableStatement = (table, schema) => {
  // Map MySQL data types to SQL Server
  const mappedColumns = table.columns.map(column => ({
    ...column,
    dataType: mapDataType(column.dataType)
  }));
  
  const columnDefinitions = mappedColumns.map(column => {
    let definition = `[${column.name}] ${column.dataType}`;
    
    if (column.isNullable === false) {
      definition += ' NOT NULL';
    } else {
      definition += ' NULL';
    }
    
    if (column.defaultValue) {
      definition += ` DEFAULT ${formatDefaultValue(column.defaultValue)}`;
    }
    
    if (column.isPrimaryKey && !isCompositePrimaryKey(table)) {
      definition += ' PRIMARY KEY';
      
      // Add IDENTITY for auto-increment primary key columns
      if (['INT', 'BIGINT', 'SMALLINT', 'TINYINT'].includes(column.dataType.toUpperCase())) {
        definition += ' IDENTITY(1,1)';
      }
    }
    
    return definition;
  });
  
  // Handle composite primary keys
  const primaryKeyColumns = table.columns.filter(column => column.isPrimaryKey);
  if (primaryKeyColumns.length > 1) {
    const pkDefinition = `CONSTRAINT [PK_${table.name}] PRIMARY KEY (${primaryKeyColumns.map(col => `[${col.name}]`).join(', ')})`;
    columnDefinitions.push(pkDefinition);
  }
  
  // SQL Server doesn't support inline foreign key constraints in CREATE TABLE
  // We'll use ALTER TABLE statements for these
  
  // Unique constraints
  const uniqueColumns = table.columns.filter(column => column.isUnique && !column.isPrimaryKey);
  uniqueColumns.forEach(column => {
    columnDefinitions.push(`CONSTRAINT [UQ_${table.name}_${column.name}] UNIQUE ([${column.name}])`);
  });
  
  return `-- Table: ${table.name}
IF OBJECT_ID(N'[dbo].[${table.name}]', N'U') IS NULL
BEGIN
CREATE TABLE [dbo].[${table.name}] (
  ${columnDefinitions.join(',\n  ')}
);

-- Add table description
EXEC sys.sp_addextendedproperty 
  @name = N'Description', 
  @value = N'${(table.description || '').replace(/'/g, "''")}',
  @level0type = N'SCHEMA', @level0name = N'dbo',
  @level1type = N'TABLE',  @level1name = N'${table.name}';
  
${mappedColumns.map(column => `
-- Add column description for ${column.name}
EXEC sys.sp_addextendedproperty 
  @name = N'Description', 
  @value = N'${(column.description || '').replace(/'/g, "''")}',
  @level0type = N'SCHEMA', @level0name = N'dbo',
  @level1type = N'TABLE',  @level1name = N'${table.name}',
  @level2type = N'COLUMN', @level2name = N'${column.name}';`).join('\n')}
END
GO`;
};

/**
 * Generate CREATE INDEX statements for SQL Server
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {Array} - CREATE INDEX statements
 */
exports.createIndexStatements = (table, schema) => {
  const indexes = [];
  
  // Add indexes for foreign keys
  const foreignKeyColumns = table.columns.filter(column => column.isForeignKey);
  
  foreignKeyColumns.forEach(column => {
    indexes.push(`-- Index for foreign key: ${column.name}
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = N'IX_${table.name}_${column.name}' AND object_id = OBJECT_ID(N'[dbo].[${table.name}]'))
BEGIN
  CREATE INDEX [IX_${table.name}_${column.name}] ON [dbo].[${table.name}] ([${column.name}]);
END
GO`);
  });
  
  return indexes;
};

/**
 * Generate ALTER TABLE statement for adding foreign key
 * @param {string} tableName - Table name
 * @param {Object} foreignKey - Foreign key constraint
 * @returns {string} - ALTER TABLE statement
 */
exports.addForeignKeyStatement = (tableName, foreignKey) => {
  return `-- Add foreign key constraint
IF OBJECT_ID(N'[dbo].[FK_${tableName}_${foreignKey.columnName}]', N'F') IS NULL
BEGIN
  ALTER TABLE [dbo].[${tableName}]
  ADD CONSTRAINT [FK_${tableName}_${foreignKey.columnName}]
  FOREIGN KEY ([${foreignKey.columnName}])
  REFERENCES [dbo].[${foreignKey.referenceTable}]([${foreignKey.referenceColumn}])
  ON DELETE ${foreignKey.onDelete}
  ON UPDATE ${foreignKey.onUpdate};
END
GO`;
};

/**
 * Format default value for SQL Server
 * @param {string} value - Default value
 * @returns {string} - Formatted default value
 */
function formatDefaultValue(value) {
  if (value === 'CURRENT_TIMESTAMP') {
    return 'GETDATE()';
  } else if (value === 'NULL') {
    return 'NULL';
  }
  return `'${value}'`;
}

/**
 * Check if table has composite primary key
 * @param {Object} table - Table object
 * @returns {boolean} - True if table has composite primary key
 */
function isCompositePrimaryKey(table) {
  return table.columns.filter(column => column.isPrimaryKey).length > 1;
}

/**
 * Map MySQL data types to SQL Server data types
 * @param {string} dataType - MySQL data type
 * @returns {string} - SQL Server data type
 */
function mapDataType(dataType) {
  const typeMap = {
    'INT': 'INT',
    'INTEGER': 'INT',
    'TINYINT': 'TINYINT',
    'SMALLINT': 'SMALLINT',
    'MEDIUMINT': 'INT',
    'BIGINT': 'BIGINT',
    'FLOAT': 'FLOAT',
    'DOUBLE': 'FLOAT',
    'DECIMAL': 'DECIMAL',
    'CHAR': 'CHAR',
    'VARCHAR': 'VARCHAR',
    'TEXT': 'NVARCHAR(MAX)',
    'TINYTEXT': 'NVARCHAR(255)',
    'MEDIUMTEXT': 'NVARCHAR(MAX)',
    'LONGTEXT': 'NVARCHAR(MAX)',
    'BOOLEAN': 'BIT',
    'DATE': 'DATE',
    'DATETIME': 'DATETIME',
    'TIMESTAMP': 'DATETIME2',
    'TIME': 'TIME',
    'YEAR': 'INT',
    'BLOB': 'VARBINARY(MAX)',
    'TINYBLOB': 'VARBINARY(255)',
    'MEDIUMBLOB': 'VARBINARY(MAX)',
    'LONGBLOB': 'VARBINARY(MAX)'
  };
  
  // Extract type and size
  const match = dataType.match(/^(\w+)(?:\(([^)]+)\))?$/);
  if (!match) return dataType;
  
  const type = match[1].toUpperCase();
  const size = match[2];
  
  // Map the type
  const baseType = typeMap[type] || type;
  
  // Add the size if applicable
  if (size && (baseType === 'VARCHAR' || baseType === 'NVARCHAR' || baseType === 'CHAR' || baseType === 'NCHAR' || baseType === 'DECIMAL')) {
    return `${baseType}(${size})`;
  }
  
  return baseType;
}

module.exports = exports;
